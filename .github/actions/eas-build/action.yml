# üîó Links:
# Source file: https://github.com/obytes/react-native-template-obytes/blob/master/.github/actions/eas-build/action.yml
# EAS Build docs: https://docs.expo.dev/eas-update/github-actions/

# ‚úçÔ∏è Description:
# This is a composite action, which means it can be used in other actions.
# This action is used to trigger an EAS Build for a specific environment (development, staging, production).
# This action accepts those inputs:
#        `APP_ENV`, which is used to generate an APK for a specific environment (development, staging, production). We use staging by default.
#        `AUTO_SUBMIT`, false by default, set to true if you want to automatically submit your build to stores.
#        `EXPO_TOKEN`, required, access token for your Expo account. https://expo.dev/settings/access-tokens
#        `VERSION`, required, version of the app to build. used as the build message.
#        `ANDROID`, true by default, set to true if you don't want to trigger build for Android.
#        `IOS`, false by default, set to true if you  want to trigger build for IOS.

# Before triggering the build, we run a pre-build script to generate the necessary native folders based on the APP_ENV.
# Based on the ANDROID and IOS inputs, we trigger the build for the corresponding platform with the corresponding flags.

# üëÄ Example usage:
#      - name: ‚è±Ô∏è EAS Build
#        uses: ./.github/actions/eas-build
#        with:
#          APP_ENV: staging
#          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
#          VERSION: ${{ github.event.release.tag_name }}
#          IOS: false

---
name: 'Setup EAS Build + Trigger Build'
description: 'Setup EAS Build + Trigger Build'
inputs:
  APP_ENV:
    description: 'APP_ENV (one of): development, staging, production'
    required: true
    default: 'staging'
  AUTO_SUBMIT: ## TODO: we need to handle this too
    description: 'AUTO_SUBMIT (one of): true, false'
    required: true
    default: 'false'
  ANDROID:
    description: 'run for ANDROID (one of): true, false'
    required: true
    default: 'true'
  VERSION:
    description: 'VERSION'
    required: true
    default: '0.0.0'
  IOS:
    description: 'run for IOS (one of): true, false'
    required: true
    default: 'false'
  EXPO_TOKEN:
    description: 'EXPO_TOKEN'
    required: true
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: üíØ Check for EXPO_TOKEN
      run: |
        # Treat empty string or the literal 'false' as missing token (GitHub Actions may pass the default string 'false')
        if [ -z "${{ inputs.EXPO_TOKEN }}" ] || [ "${{ inputs.EXPO_TOKEN }}" = "false" ]; then
          echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/eas-update/github-actions"
          exit 1
        fi
      shell: bash

    - name: üì¶ Setup Expo and EAS
      uses: expo/expo-github-action@v8
      with:
        eas-version: 12.x
        token: ${{ inputs.EXPO_TOKEN }}

    - name: üîí Validate channel mapping
      run: |
        case "${{ inputs.APP_ENV }}" in
          production)
            REQUIRED_CHANNEL=production
            ;;
          staging)
            REQUIRED_CHANNEL=staging
            ;;
          *)
            REQUIRED_CHANNEL=preview
            ;;
        esac
        echo "Required EAS channel: $REQUIRED_CHANNEL"
        # Export so subprocesses (node) can read it from environment
        export REQUIRED_CHANNEL

        # Use the JSON output from EAS CLI and parse with node to perform an exact-match check.
        # Capture both stdout and stderr so we can report CLI failures reliably.
        CHANNELS_OUTPUT="$(eas channel:list --json 2>&1)"
        EAS_EXIT_CODE=$?
        if [ $EAS_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Failed to list EAS channels (eas channel:list returned exit code" \
            "$EAS_EXIT_CODE)."
          echo "$CHANNELS_OUTPUT"
          exit 1
        fi

        # Parse JSON and extract channel names. The CLI typically returns an array of channel objects.
        # Pipe the JSON into node via a bash heredoc to avoid YAML parsing issues with
        # single-quoted inline scripts and to keep lines short for yamllint.
        printf '%s' "$CHANNELS_OUTPUT" | node <<'NODE_SCRIPT'
const fs = require("fs");
const input = fs.readFileSync(0, "utf8");
let arr;
try {
  arr = JSON.parse(input);
} catch (e) {
  console.error("‚ùå Invalid JSON returned by eas channel:list:", e.message);
  process.exit(2);
}
const names = Array.isArray(arr)
  ? arr.map(c => c && c.name).filter(Boolean)
  : (arr && arr.channels
    ? arr.channels.map(c => c && c.name).filter(Boolean)
    : []);
const required = process.env.REQUIRED_CHANNEL;
if (!required) {
  console.error("‚ùå REQUIRED channel not set in environment.");
  process.exit(4);
}
if (names.includes(required)) {
  console.log("‚úÖ Found required EAS channel:", required);
  process.exit(0);
} else {
  console.error("‚ùå Required EAS channel '" + required + "' not found. Available channels: " + names.join(", "));
  process.exit(3);
}
NODE_SCRIPT
      shell: bash

    - name: ‚öôÔ∏è Run Prebuild
      run: pnpm prebuild:${{ inputs.APP_ENV }}
      shell: bash

    - name: üì± Run Android Build
      if: ${{ inputs.ANDROID == 'true' }}
      run: pnpm build:${{ inputs.APP_ENV }}:android --non-interactive  --no-wait --message "Build  ${{ inputs.APP_ENV }} ${{ inputs.VERSION }}"
      shell: bash

    - name: üì± Run IOS Build
      if: ${{ inputs.IOS == 'true' }}
      run: pnpm build:${{ inputs.APP_ENV }}:ios --non-interactive  --no-wait --message "Build ${{ inputs.APP_ENV }} ${{ inputs.VERSION }}"
      shell: bash
