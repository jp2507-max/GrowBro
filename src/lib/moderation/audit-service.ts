/**
 * Audit Service - Comprehensive audit trail management
 *
 * Implements:
 * - Immutable event logging with cryptographic signatures
 * - Audit trail query engine with access control
 * - Chain of custody tracking
 * - Signature verification for tamper detection
 *
 * DSA Compliance: Art. 24(5) (Transparency DB integrity)
 * GDPR Compliance: Art. 5(1)(f) (integrity and confidentiality)
 *
 * Requirements: 6.1, 6.2, 6.6, 14.1, 14.3
 */

import type { SupabaseClient } from '@supabase/supabase-js';

import type {
  ActorType,
  AuditEvent,
  AuditEventInput,
  AuditEventType,
  IntegrityResult,
} from '@/types/moderation';

export interface AuditQuery {
  event_type?: AuditEventType | AuditEventType[];
  actor_id?: string;
  target_id?: string;
  target_type?: string;
  start_date?: Date;
  end_date?: Date;
  limit?: number;
  offset?: number;
}

export interface AuditTrail {
  events: AuditEvent[];
  total_count: number;
  has_more: boolean;
}

export interface AccessLogMetadata {
  accessor_id: string;
  accessor_type: ActorType;
  purpose: string;
  query_parameters: AuditQuery;
  permission_verified: boolean;
}

export interface RetentionPolicy {
  default_retention_days: number;
  audit_events_retention_days: number; // 7 years = 2555 days
  pii_anonymization_days: number; // 30 days
}

interface DbAuditEventRow {
  id: string;
  event_type: string;
  actor_id: string;
  actor_type: string;
  target_id: string;
  target_type: string;
  action: string;
  metadata: Record<string, unknown>;
  timestamp: string;
  signature: string;
  pii_tagged: boolean;
  retention_until: string;
  created_at: string;
}

const DEFAULT_RETENTION_POLICY: RetentionPolicy = {
  default_retention_days: 365, // 12 months
  audit_events_retention_days: 2555, // 7 years
  pii_anonymization_days: 30,
};

export class AuditService {
  constructor(
    private supabase: SupabaseClient,
    private retentionPolicy: RetentionPolicy = DEFAULT_RETENTION_POLICY
  ) {}

  /**
   * Log an immutable audit event
   * Requirements: 6.1, 6.6
   *
   * @param event - Audit event input data
   * @returns Promise<AuditEvent> - Created audit event with signature
   */
  async logEvent(event: AuditEventInput): Promise<AuditEvent> {
    const timestamp = new Date();
    const retention_until = this.calculateRetentionDate(
      event.event_type,
      event.pii_tagged ?? false
    );

    // Insert event - signature will be auto-generated by DB trigger
    const { data, error } = await this.supabase
      .from('audit_events')
      .insert({
        event_type: event.event_type,
        actor_id: event.actor_id,
        actor_type: event.actor_type,
        target_id: event.target_id,
        target_type: event.target_type,
        action: event.action,
        metadata: event.metadata ?? {},
        timestamp,
        pii_tagged: event.pii_tagged ?? false,
        retention_until,
        signature: '', // Will be auto-generated by trigger
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to log audit event: ${error.message}`);
    }

    return this.mapToAuditEvent(data as DbAuditEventRow);
  }

  /**
   * Query audit trail with access control logging
   * Requirements: 6.2, 14.3
   *
   * @param query - Query parameters for filtering events
   * @param accessor - Information about who is accessing the audit trail
   * @returns Promise<AuditTrail> - Filtered audit events
   */
  async queryAuditTrail(
    query: AuditQuery,
    accessor: {
      accessor_id: string;
      accessor_type: ActorType;
      purpose: string;
    }
  ): Promise<AuditTrail> {
    // Log the access to audit trail (chain of custody)
    await this.logAuditAccess({
      accessor_id: accessor.accessor_id,
      accessor_type: accessor.accessor_type,
      purpose: accessor.purpose,
      query_parameters: query,
      permission_verified: true, // Should be verified by RLS/middleware
    });

    // Build query
    let supabaseQuery = this.supabase.from('audit_events').select('*', {
      count: 'exact',
    });

    // Apply filters
    if (query.event_type) {
      if (Array.isArray(query.event_type)) {
        supabaseQuery = supabaseQuery.in('event_type', query.event_type);
      } else {
        supabaseQuery = supabaseQuery.eq('event_type', query.event_type);
      }
    }

    if (query.actor_id) {
      supabaseQuery = supabaseQuery.eq('actor_id', query.actor_id);
    }

    if (query.target_id) {
      supabaseQuery = supabaseQuery.eq('target_id', query.target_id);
    }

    if (query.target_type) {
      supabaseQuery = supabaseQuery.eq('target_type', query.target_type);
    }

    if (query.start_date) {
      supabaseQuery = supabaseQuery.gte(
        'timestamp',
        query.start_date.toISOString()
      );
    }

    if (query.end_date) {
      supabaseQuery = supabaseQuery.lte(
        'timestamp',
        query.end_date.toISOString()
      );
    }

    // Order by timestamp descending
    supabaseQuery = supabaseQuery.order('timestamp', { ascending: false });

    // Apply pagination
    const limit = query.limit ?? 100;
    const offset = query.offset ?? 0;
    supabaseQuery = supabaseQuery.range(offset, offset + limit - 1);

    const { data, error, count } = await supabaseQuery;

    if (error) {
      throw new Error(`Failed to query audit trail: ${error.message}`);
    }

    const events = ((data as DbAuditEventRow[]) ?? []).map((row) =>
      this.mapToAuditEvent(row)
    );
    const total_count = count ?? 0;

    return {
      events,
      total_count,
      has_more: offset + limit < total_count,
    };
  }

  /**
   * Verify cryptographic signature of an audit event
   * Requirements: 6.6
   *
   * @param event_id - UUID of the audit event to verify
   * @returns Promise<IntegrityResult> - Verification result
   */
  async verifyIntegrity(event_id: string): Promise<IntegrityResult> {
    // Call DB function to verify signature
    const { data, error } = await this.supabase.rpc('verify_audit_signature', {
      p_event_id: event_id,
    });

    if (error) {
      return {
        is_valid: false,
        event_id,
        expected_signature: '',
        actual_signature: '',
        error: error.message,
      };
    }

    // Fetch event to get signatures
    const { data: event } = await this.supabase
      .from('audit_events')
      .select('signature')
      .eq('id', event_id)
      .single();

    return {
      is_valid: data as boolean,
      event_id,
      expected_signature: event?.signature ?? '',
      actual_signature: event?.signature ?? '',
    };
  }

  /**
   * Verify integrity of entire partition
   * Requirements: 6.6
   *
   * @param partition_name - Name of the partition to verify
   * @returns Promise<boolean> - True if partition is valid
   */
  async verifyPartitionIntegrity(partition_name: string): Promise<boolean> {
    // Generate fresh checksum
    const { data, error } = await this.supabase.rpc(
      'generate_partition_checksum',
      {
        p_partition_name: partition_name,
      }
    );

    if (error) {
      throw new Error(
        `Failed to generate partition checksum: ${error.message}`
      );
    }

    const { record_count, checksum } = data[0];

    // Compare with stored manifest
    const { data: manifest } = await this.supabase
      .from('partition_manifests')
      .select('*')
      .eq('partition_name', partition_name)
      .single();

    if (!manifest) {
      // No manifest exists - first verification, create it
      await this.supabase.from('partition_manifests').insert({
        table_name: 'audit_events',
        partition_name,
        partition_start_date: this.getPartitionStartDate(partition_name),
        partition_end_date: this.getPartitionEndDate(partition_name),
        record_count,
        checksum,
        manifest_signature: checksum, // Simplified for now
        last_verified_at: new Date().toISOString(),
        verification_status: 'valid',
      });
      return true;
    }

    // Compare checksums
    const is_valid = manifest.checksum === checksum;

    // Update manifest
    await this.supabase
      .from('partition_manifests')
      .update({
        last_verified_at: new Date().toISOString(),
        verification_status: is_valid ? 'valid' : 'tampered',
      })
      .eq('partition_name', partition_name);

    return is_valid;
  }

  /**
   * Get audit events for a specific target
   * Requirements: 6.1, 6.2
   *
   * @param target_id - ID of the target entity
   * @param target_type - Type of the target entity
   * @returns Promise<AuditEvent[]> - All audit events for target
   */
  async getTargetAuditTrail(
    target_id: string,
    target_type: string
  ): Promise<AuditEvent[]> {
    const { data, error } = await this.supabase
      .from('audit_events')
      .select('*')
      .eq('target_id', target_id)
      .eq('target_type', target_type)
      .order('timestamp', { ascending: true });

    if (error) {
      throw new Error(`Failed to get target audit trail: ${error.message}`);
    }

    return ((data as DbAuditEventRow[]) ?? []).map((row) =>
      this.mapToAuditEvent(row)
    );
  }

  /**
   * Get SoR submission trail for legal transparency
   * Requirements: 6.1
   *
   * @param decision_id - UUID of the moderation decision
   * @returns Promise<SoRSubmissionTrail> - Submission trail details
   */
  async getSoRSubmissionTrail(decision_id: string): Promise<{
    statement_id: string;
    payload_hash: string;
    submitted_at: Date | null;
    transparency_db_id: string | null;
    attempts: number;
    status: string;
  } | null> {
    const { data, error } = await this.supabase
      .from('sor_submission_trail_view')
      .select('*')
      .eq('decision_id', decision_id)
      .single();

    if (error || !data) {
      return null;
    }

    return {
      statement_id: data.statement_id,
      payload_hash: data.payload_hash,
      submitted_at: data.submitted_at ? new Date(data.submitted_at) : null,
      transparency_db_id: data.transparency_db_id,
      attempts: data.attempts,
      status: data.status,
    };
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  /**
   * Log access to audit trail (chain of custody)
   */
  private async logAuditAccess(metadata: AccessLogMetadata): Promise<void> {
    await this.logEvent({
      event_type: 'audit_access',
      actor_id: metadata.accessor_id,
      actor_type: metadata.accessor_type,
      target_id: 'audit_trail',
      target_type: 'system',
      action: 'query',
      metadata: {
        purpose: metadata.purpose,
        query_parameters: metadata.query_parameters,
        permission_verified: metadata.permission_verified,
      },
      pii_tagged: false,
    });
  }

  /**
   * Calculate retention date based on event type and PII status
   */
  private calculateRetentionDate(
    event_type: AuditEventType,
    pii_tagged: boolean
  ): Date {
    const now = new Date();
    let retention_days: number;

    // Audit events have 7-year retention for compliance
    if (
      event_type === 'decision_made' ||
      event_type === 'appeal_filed' ||
      event_type === 'sor_submitted' ||
      event_type === 'audit_access'
    ) {
      retention_days = this.retentionPolicy.audit_events_retention_days;
    } else {
      retention_days = this.retentionPolicy.default_retention_days;
    }

    // PII should be anonymized earlier
    if (pii_tagged) {
      retention_days = Math.min(
        retention_days,
        this.retentionPolicy.pii_anonymization_days
      );
    }

    return new Date(now.getTime() + retention_days * 24 * 60 * 60 * 1000);
  }

  /**
   * Map database row to AuditEvent interface
   */
  private mapToAuditEvent(row: DbAuditEventRow): AuditEvent {
    return {
      id: row.id,
      event_type: row.event_type as AuditEventType,
      actor_id: row.actor_id,
      actor_type: row.actor_type as ActorType,
      target_id: row.target_id,
      target_type: row.target_type,
      action: row.action,
      metadata: row.metadata,
      timestamp: new Date(row.timestamp),
      signature: row.signature,
      pii_tagged: row.pii_tagged,
      retention_until: new Date(row.retention_until),
      created_at: new Date(row.created_at),
    };
  }

  /**
   * Parse partition name to get start date
   */
  private getPartitionStartDate(partition_name: string): string {
    // Format: audit_events_YYYYMM
    const match = partition_name.match(/audit_events_(\d{4})(\d{2})/);
    if (!match) {
      throw new Error(`Invalid partition name: ${partition_name}`);
    }
    const [, year, month] = match;
    return `${year}-${month}-01`;
  }

  /**
   * Parse partition name to get end date
   */
  private getPartitionEndDate(partition_name: string): string {
    const start = new Date(this.getPartitionStartDate(partition_name));
    const end = new Date(start);
    end.setMonth(end.getMonth() + 1);
    return end.toISOString().split('T')[0];
  }
}
