/**
 * Geo-Location Service
 * Privacy-first geographic content filtering with DSA compliance
 * Part of Task 10: Geo-Location Service (Requirements 9.1-9.7)
 *
 * Key Features:
 * - IP-based geolocation (default, no consent required)
 * - GPS location with explicit consent
 * - Regional content filtering with SoR integration
 * - VPN/proxy detection (config-driven)
 * - 1-hour location cache with TTL
 * - Author notifications for geo-restrictions
 * - Appeal flow for false positives
 */

import { supabase } from '@/lib/supabase';
import type {
  AvailabilityResult,
  CreateGeoRestrictionInput,
  GeoLocationService as IGeoLocationService,
  IPLocationRequest,
  LocationData,
  LocationResult,
  VpnDetectionResult,
} from '@/types/geo-location';
import { GeoLocationError } from '@/types/geo-location';

import {
  expandEuRegionCode,
  GEO_RESTRICTION_EXPLAINERS,
  getGeoLocationConfig,
  VPN_DETECTION_CONFIG,
} from './geo-config';

/**
 * Core implementation of geo-location service
 */
export class GeoLocationService implements IGeoLocationService {
  private config = getGeoLocationConfig();

  /**
   * Detect user location using IP address (default method, no consent required)
   * Requirement 9.1: Default to server-side IP-based geolocation
   */
  async detectUserLocationIP(
    request: IPLocationRequest
  ): Promise<LocationResult> {
    try {
      const { data, error } = await supabase.functions.invoke(
        'ip-geolocation',
        {
          body: {
            ipAddress: request.ipAddress,
            includeVpnCheck:
              request.includeVpnCheck ?? this.config.vpnBlockingEnabled,
          },
        }
      );

      if (error) {
        throw new Error(`IP geolocation failed: ${error.message}`);
      }

      const locationData: LocationData = {
        country: data.country,
        region: data.region,
        city: data.city,
        timezone: data.timezone,
      };

      const result: LocationResult = {
        location: locationData,
        method: 'ip',
        vpnDetected: data.vpnDetected ?? false,
        confidenceScore: data.confidence ?? 1.0,
        timestamp: new Date(),
      };

      // Cache the result
      await this.cacheLocation(result);

      return result;
    } catch (error) {
      throw this.handleError(error, 'IP_LOOKUP_FAILED', {
        ipAddress: request.ipAddress,
      });
    }
  }

  /**
   * Request GPS location with explicit user consent
   * Requirement 9.1: GPS only with explicit consent and clear user benefit
   */
  async requestGPSLocation(
    userId: string,
    purpose: string,
    hasConsent: boolean
  ): Promise<LocationResult> {
    if (!hasConsent) {
      throw new GeoLocationError(
        'GPS location requires explicit user consent',
        'GPS_PERMISSION_DENIED',
        { userId, purpose }
      );
    }

    try {
      // GPS location is handled client-side in React Native
      // This method validates consent and logs the request
      const { error } = await supabase.from('audit_events').insert({
        event_type: 'gps_location_requested',
        actor_id: userId,
        actor_type: 'user',
        target_id: userId,
        target_type: 'location',
        action: 'request_gps',
        metadata: {
          purpose,
          hasConsent,
          timestamp: new Date().toISOString(),
        },
        signature: '', // Generated by audit service
      });

      if (error) {
        console.warn('Failed to log GPS request:', error);
      }

      // Return placeholder - actual GPS data comes from React Native hook
      throw new GeoLocationError(
        'GPS location must be requested from React Native client',
        'GPS_UNAVAILABLE',
        { userId, purpose }
      );
    } catch (error) {
      throw this.handleError(error, 'GPS_UNAVAILABLE', { userId, purpose });
    }
  }

  /**
   * Check if content is available in user's location
   * Requirement 9.2: Apply most restrictive setting on signal mismatch
   * Requirement 9.3: Provide "why can't I see this?" explainer
   */
  async checkContentAvailability(
    contentId: string,
    location: LocationData
  ): Promise<AvailabilityResult> {
    try {
      // Call stored procedure for efficient availability check
      const { data, error } = await supabase.rpc(
        'check_content_geo_availability',
        {
          p_content_id: contentId,
          p_user_location: location,
        }
      );

      if (error) {
        throw error;
      }

      const result = data as {
        available: boolean;
        reason?: string;
        lawful_basis?: string;
        affected_regions?: string[];
      };

      if (!result.available && result.reason) {
        return {
          available: false,
          reason: result.reason as AvailabilityResult['reason'],
          lawfulBasis: result.lawful_basis,
          affectedRegions: result.affected_regions,
          explainerText: this.generateExplainerText(
            result.reason as AvailabilityResult['reason'],
            result.affected_regions || []
          ),
        };
      }

      return {
        available: true,
      };
    } catch (error) {
      throw this.handleError(error, 'RESTRICTION_NOT_FOUND', {
        contentId,
        location,
      });
    }
  }

  /**
   * Apply geo-restriction to content
   * Requirement 9.7: Notify authors about regional visibility limitations
   */
  async applyGeoRestriction(
    contentId: string,
    restrictedRegions: string[],
    includeInSoR: boolean
  ): Promise<void> {
    try {
      // Expand 'EU' to all EU member states
      const expandedRegions = expandEuRegionCode(restrictedRegions);

      // Note: Full input requires additional fields - this simplified signature
      // matches the interface. For production use, accept CreateGeoRestrictionInput.
      const restriction: Partial<CreateGeoRestrictionInput> = {
        contentId,
        restrictedRegions: expandedRegions,
        includeInSoR,
        contentType: 'post', // Default; should be passed as parameter
        lawfulBasis: 'To be specified', // Should be passed as parameter
        reasonCode: 'policy_violation', // Should be passed as parameter
      };

      const { error } = await supabase
        .from('geo_restrictions')
        .insert({
          content_id: restriction.contentId,
          content_type: restriction.contentType,
          restricted_regions: restriction.restrictedRegions,
          lawful_basis: restriction.lawfulBasis,
          reason_code: restriction.reasonCode,
          include_in_sor: restriction.includeInSoR,
        })
        .select()
        .single();

      if (error) {
        throw error;
      }

      // Get content author for notification
      const { data: contentData, error: contentError } = await supabase
        .from('posts')
        .select('user_id')
        .eq('id', contentId)
        .single();

      if (contentError) {
        console.warn('Failed to get content author:', contentError);
        return;
      }

      // Notify author about restriction
      await this.notifyGeoRestriction(
        contentData.user_id,
        contentId,
        expandedRegions
      );
    } catch (error) {
      throw this.handleError(error, 'RESTRICTION_NOT_FOUND', {
        contentId,
        restrictedRegions,
      });
    }
  }

  /**
   * Notify author about geo-restriction on their content
   * Requirement 9.7: Provide author notifications indicating affected regions
   */
  async notifyGeoRestriction(
    userId: string,
    contentId: string,
    regions: string[]
  ): Promise<void> {
    try {
      // Get restriction details
      const { data: restriction, error: restrictionError } = await supabase
        .from('geo_restrictions')
        .select('*')
        .eq('content_id', contentId)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (restrictionError) {
        throw restrictionError;
      }

      // Create notification record
      const { error: notificationError } = await supabase
        .from('geo_restriction_notifications')
        .insert({
          restriction_id: restriction.id,
          recipient_id: userId,
          notification_type: 'author_alert',
          delivery_method: 'in_app', // Can be extended to push/email
          delivery_status: 'pending',
        });

      if (notificationError) {
        throw notificationError;
      }

      // Send actual notification via notification service
      // This would integrate with expo-notifications or email service
      await this.sendNotification(userId, {
        title: 'Content Restricted in Some Regions',
        body: `Your content is not visible in ${regions.join(', ')} due to regional restrictions.`,
        data: {
          type: 'geo_restriction',
          contentId,
          regions,
          lawfulBasis: restriction.lawful_basis,
        },
      });
    } catch (error) {
      throw this.handleError(error, 'NOTIFICATION_FAILED', {
        userId,
        contentId,
        regions,
      });
    }
  }

  /**
   * Set VPN/proxy blocking configuration
   * Requirement 9.5: Config-driven VPN/proxy detection
   */
  async setVpnBlocking(enabled: boolean): Promise<void> {
    this.config.vpnBlockingEnabled = enabled;

    // Update configuration in database
    await supabase.from('app_config').upsert({
      key: 'geo_vpn_blocking_enabled',
      value: enabled,
      updated_at: new Date().toISOString(),
    });
  }

  /**
   * Get cache TTL in milliseconds
   * Default: 1 hour (3600000ms)
   */
  getDecisionTtlMs(): number {
    return this.config.cacheTtlMs;
  }

  /**
   * Detect VPN/proxy usage
   * Requirement 9.5: VPN detection with 1-hour cache TTL
   */
  async detectVpn(ipAddress: string): Promise<VpnDetectionResult> {
    try {
      // Check cache first
      const cachedResult = await this.getCachedVpnDetection(ipAddress);
      if (cachedResult) {
        return { ...cachedResult, cached: true };
      }

      // Call VPN detection service (e.g., IPHub, IPQualityScore)
      const { data, error } = await supabase.functions.invoke('detect-vpn', {
        body: { ipAddress },
      });

      if (error) {
        throw error;
      }

      const result: VpnDetectionResult = {
        detected: data.isVpn ?? false,
        confidence: data.confidence ?? 0,
        reason: data.reason,
        cached: false,
      };

      // Cache the result
      await this.cacheVpnDetection(ipAddress, result);

      return result;
    } catch (error) {
      console.warn('VPN detection failed, assuming no VPN:', error);
      return {
        detected: false,
        confidence: 0,
        cached: false,
      };
    }
  }

  /**
   * Resolve signal mismatch (IP vs device region)
   * Requirement 9.2: Apply most restrictive setting
   */
  resolveSignalMismatch(
    ipLocation: LocationData,
    _deviceLocation: LocationData
  ): LocationData {
    // For now, use IP location as primary (server-side, harder to spoof)
    // Future: implement sophisticated mismatch detection and logging
    return ipLocation;
  }

  /**
   * Cache user location data
   */
  private async cacheLocation(result: LocationResult): Promise<void> {
    try {
      const expiresAt = new Date(Date.now() + this.config.cacheTtlMs);

      await supabase.from('geo_location_cache').upsert({
        user_id: (await supabase.auth.getUser()).data.user?.id,
        location_method: result.method,
        location_data: result.location,
        vpn_detected: result.vpnDetected ?? false,
        confidence_score: result.confidenceScore,
        expires_at: expiresAt.toISOString(),
        cached_at: new Date().toISOString(),
      });
    } catch (error) {
      console.warn('Failed to cache location:', error);
    }
  }

  /**
   * Get cached VPN detection result
   */
  private async getCachedVpnDetection(
    ipAddress: string
  ): Promise<VpnDetectionResult | null> {
    try {
      const { data, error } = await supabase
        .from('vpn_detection_cache')
        .select('*')
        .eq('ip_address', ipAddress)
        .gt('expires_at', new Date().toISOString())
        .single();

      if (error || !data) {
        return null;
      }

      return {
        detected: data.is_vpn,
        confidence: data.confidence,
        reason: data.reason,
        cached: true,
      };
    } catch {
      return null;
    }
  }

  /**
   * Cache VPN detection result
   */
  private async cacheVpnDetection(
    ipAddress: string,
    result: VpnDetectionResult
  ): Promise<void> {
    try {
      const expiresAt = new Date(
        Date.now() + VPN_DETECTION_CONFIG.CACHE_TTL_MS
      );

      await supabase.from('vpn_detection_cache').upsert({
        ip_address: ipAddress,
        is_vpn: result.detected,
        confidence: result.confidence,
        reason: result.reason,
        expires_at: expiresAt.toISOString(),
        cached_at: new Date().toISOString(),
      });
    } catch (error) {
      console.warn('Failed to cache VPN detection:', error);
    }
  }

  /**
   * Generate user-facing explainer text for geo-restrictions
   * Requirement 9.3: Provide "why can't I see this?" explainer
   */
  private generateExplainerText(
    reasonCode: AvailabilityResult['reason'],
    regions: string[]
  ): string {
    if (!reasonCode) {
      return 'This content is not available in your region.';
    }

    const template = GEO_RESTRICTION_EXPLAINERS[reasonCode];
    return template
      ? template(regions)
      : 'This content is not available in your region.';
  }

  /**
   * Send notification to user (integrates with notification service)
   */
  private async sendNotification(
    userId: string,
    notification: {
      title: string;
      body: string;
      data?: Record<string, unknown>;
    }
  ): Promise<void> {
    try {
      // This would integrate with expo-notifications or push notification service
      await supabase.functions.invoke('send-notification', {
        body: {
          userId,
          ...notification,
        },
      });
    } catch (error) {
      console.warn('Failed to send notification:', error);
    }
  }

  /**
   * Handle errors with consistent error types
   */
  private handleError(
    error: unknown,
    code: GeoLocationError['code'],
    metadata?: Record<string, unknown>
  ): GeoLocationError {
    if (error instanceof GeoLocationError) {
      return error;
    }

    const message = error instanceof Error ? error.message : String(error);
    return new GeoLocationError(message, code, metadata);
  }
}

/**
 * Singleton instance
 */
export const geoLocationService = new GeoLocationService();
