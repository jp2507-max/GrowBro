// Gradle init/applied script to verify per-variant targetSdk using AGP Variant APIs
// Usage: ./gradlew -I ../scripts/android/verify-targetsdk.gradle verifyTargetSdkCompliance

def EXPECTED_TARGET_SDK = {
  def envValue = System.getenv('EXPECTED_TARGET_SDK')
  if (envValue == null) {
    return 35
  }

  // Validate the string matches integer pattern
  if (!envValue.matches(/^\d+$/)) {
    logger.warn("[verifyTargetSdkCompliance] EXPECTED_TARGET_SDK '${envValue}' is not a valid integer, falling back to default: 35")
    return 35
  }

  def parsedValue = envValue as Integer

  // Verify the parsed integer falls within acceptable Android target SDK range (16-100)
  if (parsedValue < 16 || parsedValue > 100) {
    throw new GradleException("[verifyTargetSdkCompliance] EXPECTED_TARGET_SDK '${parsedValue}' is out of acceptable range (16-100). Please provide a valid Android target SDK version.")
  }

  return parsedValue
}()

def ENFORCE_VARIANTS = ['release', 'production']

gradle.rootProject { root ->
  def aggregate = root.tasks.create('verifyTargetSdkCompliance')

  root.subprojects { proj ->
    proj.plugins.withId('com.android.application') {
      def reportDir = new File(proj.buildDir, 'reports/target-sdk-compliance')
      reportDir.mkdirs()

      def checkTask = proj.tasks.create('verifyTargetSdkComplianceForModule') {
        group = 'verification'
        description = 'Verifies that enforced variants have targetSdk set to EXPECTED_TARGET_SDK.'
        doLast {
          def failures = []

          def androidExt = proj.extensions.findByName('android')
          if (androidExt && androidExt.hasProperty('applicationVariants')) {
            androidExt.applicationVariants.all { variant ->
              def variantName = variant.name
              def isEnforced = ENFORCE_VARIANTS.any { enforcedName ->
                // Check build type name for exact match
                if (variant.buildType?.name?.toLowerCase() == enforcedName) {
                  return true
                }
                // Check product flavor names for exact match
                if (variant.productFlavors?.any { flavor -> flavor.name?.toLowerCase() == enforcedName }) {
                  return true
                }
                // Fallback: check full variant name for exact match
                return variantName.toLowerCase() == enforcedName
              }
              if (!isEnforced) {
                return
              }

              def effectiveTarget = null
              try {
                effectiveTarget = variant.mergedFlavor?.targetSdkVersion?.apiLevel
              } catch (Throwable ignored) {
                effectiveTarget = null
              }

              def status = (effectiveTarget == EXPECTED_TARGET_SDK) ? 'pass' : 'fail'
              def reportData = [
                variant: variantName,
                effectiveTargetSdk: effectiveTarget,
                expectedTargetSdk: EXPECTED_TARGET_SDK,
                status: status,
                remediation: "Set targetSdkVersion ${EXPECTED_TARGET_SDK} for this variant",
                deadline: "2025-08-31"
              ]
              def json = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(reportData))
              def out = new File(reportDir, "${variantName}.json")
              out.text = json

              if (status == 'fail') {
                failures << "${proj.path}:${variantName} targetSdk=${effectiveTarget}"
              }
            }
          } else {
            logger.warn("[verifyTargetSdkCompliance] Android extension not found or applicationVariants unavailable in ${proj.path}")
          }

          if (!failures.isEmpty()) {
            throw new GradleException("Target SDK compliance failed for: \n - " + failures.join('\n - '))
          } else {
            logger.lifecycle("[verifyTargetSdkCompliance] All enforced variants compliant in ${proj.path}")
          }
        }
      }

      aggregate.dependsOn(checkTask)
    }
  }
}


