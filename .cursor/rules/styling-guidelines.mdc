---
alwaysApply: true
---

---

## applyTo: '**'

# ğŸ¬ React Native Reanimated ProductionÂ Guidelines (4.x, Expo SDKÂ 54) â€” GrowBro Edition

*Last updated: SepÂ 2025 â€¢ Agentâ€‘ready, compact but comprehensive*

---

## ğŸš€ Worklets in 4.x â€” What runs on the UI thread

* **Autoâ€‘workletization**: callbacks passed to Reanimated APIs (`useAnimatedStyle`, `useDerivedValue`, gesture callbacks, entering/exiting/layout) run on the **UI runtime**.
* **Add `'worklet'`** when you (1) call imported/external functions, (2) create worklets via expressions/ternaries, (3) define worklet callbacks inside **custom hooks**, or (4) expose reusable topâ€‘level worklet utilities.
* **`runOnUI`**: inline callbacks are workletized automatically; external references still need `'worklet'`.
* **Never read** `.value` in React render; **derive inside worklets**. Assign to shared values; avoid deep object mutations.
* **One write per frame**: donâ€™t set the same shared value multiple times in a single tick.
* **No hooks in worklets**.

```ts
// Autoâ€‘workletized (UI thread)
const animatedStyle = useAnimatedStyle(() => ({
  transform: [{ scale: scale.value }],
}));

// Imported function as a worklet
export function cardWorklet() {
  'worklet';
  return { opacity: 1 };
}
const st = useAnimatedStyle(cardWorklet);

// Expressionâ€‘defined worklet
const makeStyle = isOn
  ? () => { 'worklet'; return { opacity: 1 }; }
  : () => { 'worklet'; return { opacity: 0.5 }; };
```

---

## Reanimated 4 essentials (for agents)

* Prefer **layout/shared transitions** over manual width/height animations. Always chain `.reduceMotion(ReduceMotion.System)`.
* Use RNGH v2 **`Gesture.*()`** with **`GestureDetector`** (legacy handler components/`useAnimatedGestureHandler` are deprecated in 4.x).
* **Crossâ€‘thread boundaries**: keep UIâ€‘critical logic in worklets. Use **`runOnJS`** **sparingly** (never perâ€‘frame) for state/sideâ€‘effects **after** animations.
* Measure with `measure`, scroll with `scrollTo`, avoid layout hacks.

---

## ğŸ§­ Styling with NativeWind

* **Static** styles in `className`; **dynamic** parts via `style={animatedStyle}` from shared values.
* **Do not** flip Tailwind classes per frame. Compute animated styles instead.
* Class order: layout â†’ flex/grid â†’ spacing â†’ sizing â†’ border/radius â†’ background â†’ text/font â†’ effects â†’ state/dark.
* Use **design tokens** from `tailwind.config.js`; avoid raw hex or offâ€‘scale spacing.
* Prefer small **variant helpers** (e.g., `tv/cva`) over long JSX ternaries.
* Forward/merge `className` in custom components; keep it **stable** across frames.

---

## ğŸ§© GrowBro repoâ€‘specific styling conventions

* **Tokens source**: `src/components/ui/colors.js` (wired via Tailwind config).

  * Palettes: `primary`, `neutral`, `charcoal`, `success`, `warning`, `danger`.
  * Prefer tokens (e.g., `bg-primary-600`, `text-neutral-100`, `bg-charcoal-950`) over raw hex.
* **Fonts**: default `font-inter`; override via class names, not inline styles.
* **Dark mode**: `darkMode: 'class'`. Pair light/dark classes. App themes mirror tokens via `src/lib/use-theme-config.tsx`.
* **Variants**: compose with `tailwind-variants` `tv()`; keep layout static in slots, switch tokens via variants; allow overrides with `slots.container({ className })`.
* **SVG**: `cssInterop` enables `className` on `react-native-svg` (see `src/components/ui/index.tsx`).
* **Class merging**: use `tailwind-merge`; avoid manual concatenation.
* **Native props w/ colors**: import from `@/components/ui/colors` (e.g., `placeholderTextColor`).
* **Linting**: `eslint-plugin-tailwindcss` enforces class order.
* **Add tokens** by editing `src/components/ui/colors.js`; Tailwind already imports it.

### ğŸŒˆ Theme tokens workflow (GrowBro standard)

* **Palette first**: tweak shades in `src/components/ui/colors.js`. Tailwind classes & runtime tokens consume the same palette â†’ one change propagates everywhere.
* **Semantic roles**: `src/lib/theme-tokens.ts` defines light/dark roles for `surface`, `text`, and `action` (primary, CTA, link, focus ring). Use these instead of sprinkling palette indices inside components. Navigation reads from `themeRoles`.
* **Tailwind vs tokens**: Tailwind for **static layout** (`bg-primary-600`); **runtime** decisions use tokens (React Navigation themes, FlashMessage, focus rings, `style` props).
* **States & accessibility**: role tokens include hover/background/content + focusâ€‘ring colors; always pair CTA backgrounds with their **content** color for readable text.
* **Adding new roles**: extend `themeRoles` (document the intent) before adâ€‘hoc palette references â€” keeps contrast & theming auditâ€‘friendly.

---

## âœ… Do / Avoid (Quick)

**Do**

* Tailwind for **static**, Reanimated for **dynamic**.
* Layout/shared transitions > manual size/position.
* Honor **Reduced Motion** via `.reduceMotion(ReduceMotion.System)`.
* Centralize shared transition tags/helpers under `src/lib/animations/`.

**Avoid**

* Toggling `className` per frame.
* Nesting `Animated.View` unnecessarily; compose transforms in one container.

---

## ğŸ§  Worklet Offloading (TL;DR)

* If logic runs **per frame/gesture** and **doesnâ€™t need React state**, make it a **worklet**.
* Candidates: interpolation/physics, clamping/throttling, hitâ€‘testing, gesture math, small inâ€‘memory filters/scoring tied to UI.
* Oneâ€‘shot heavy calc tied to UI:

```ts
runOnUI(() => {
  'worklet';
  // expensive but synchronous logic here
})();
```

### Captures (Closures)

* Capture only **small, serializable** values. Avoid large objects/functions; pass **params** or use **Shared Values**.

### `runOnJS` â€” DO / DONâ€™T

**DO**

* Haptics/toasts, analytics, logging.
* Update React state **after** an animation/gesture.
  **DONâ€™T**
* Call `runOnJS` **per frame** or inside `onUpdate` loops.
* Use it for timingâ€‘critical UI logic.

### Async & Sideâ€‘Effects

* Worklets are **synchronous & sideâ€‘effectâ€‘free** (no network/storage/timers). For async/IO, jump to JS via `runOnJS`.

### Quick Perf Check

* Use Expo Dev Menu FPS monitor; ensure animations stay smooth while JS is busy.
* Log only on **events** (start/finish) via `runOnJS`, not every frame.

---

## Class Churn vs Animated Style

**Bad** (recomputes classes every frame):

```tsx
// âŒ donâ€™t flip Tailwind classes per frame
<View className={progress.value > 0.5 ? 'opacity-100' : 'opacity-50'} />
```

**Good** (use shared value + animated style):

```tsx
const opacity = useSharedValue(0.5);
const animatedStyle = useAnimatedStyle(() => ({ opacity: opacity.value }));
return <Animated.View style={animatedStyle} className="bg-primary rounded-xl" />;
```

---

## ğŸ›ï¸ Animation Choice (Cheat)

* **CSS Animations (keyframes)** â€” fireâ€‘andâ€‘forget loops/ambient effects; no React state.
* **CSS Transitions** â€” stateâ€‘triggered oneâ€‘offs (toggles, open/close, hover/focus).
* **Shared Values + `useAnimatedStyle`** â€” continuous/gesture/sensorâ€‘driven UI; pair with `withTiming`/`withSpring`/`withDecay`.
* **Layout Animations** â€” entering/exiting or reâ€‘layout of lists/sections; prefer presets before custom.

**Preset naming rule**: `<Effect><In|Out><Direction>` â†’ `BounceIn`, `ZoomInLeft`, `SlideOutRight`, `FadeOutDown`.

**Microâ€‘API reminders**: compose with `withSequence`, `withRepeat`, `withDelay`, `withClamp`; use `LinearTransition` for simple size/position changes.

---

## ğŸ§© Reanimated 4 â€” CSS API & Presets

* **CSS Animations (keyframes)**: ambient/looping effects (skeleton, shimmer, pulse). No React state.
* **CSS Transitions**: stateâ€‘driven oneâ€‘offs (width/color/opacity on toggle/press/showâ€‘hide).
* **Entering/Exiting presets**: attach on mount/unmount; tweak via `.springify()/.duration()/.easing()/.reduceMotion()`.
* **Layout transitions**: animate reâ€‘layout; start with `LinearTransition`, use `CurvedTransition` for organic motion.
* **Composition helpers**: prefer `withSequence`, `withRepeat`, `withDelay`, `withClamp` over loops.
* **Preset naming**: `<Effect><In|Out><Direction>` â†’ `BounceIn`, `SlideOutRight`, etc.
* Example components live under `src/lib/animations/examples/`.

---

## ğŸ”— Shared element transitions

* Use `sharedTransitionTag` with a **prefixed domain**, e.g., `feed.card.image`, `settings.avatar`.
* Centralize optional `sharedTransitionStyle` in `src/lib/animations/shared.ts`.
* Name tags predictably; avoid collisions by prefixing with **feature**.

---

## ğŸ–ï¸ Modern gestures (RNGH v2)

* Use the **`Gesture` builder API** with `GestureDetector`.
* Replace old `useAnimatedGestureHandler` (3.x) with `onStart/onUpdate/onEnd` chain.
* Keep your own shared `ctx` via `useSharedValue` if needed.
* Heavy math stays in **UI worklets**; no `runOnJS` inside `onUpdate`.

---

## â™»ï¸ Cleanup & chaining

* **Cancel** long/looping animations on unmount (`cancelAnimation`).
* Use composition helpers to chain sequences; fire followâ€‘up animations from finish callbacks.

---

## ğŸ”€ Crossing threads

* **UI â†’ JS**: `runOnJS(fn)(args...)` only for sideâ€‘effects, analytics, or updating React state **after** animation/gesture.
* **JS â†’ UI**: `runOnUI(() => { 'worklet'; /* ui logic */ })()`.
* Keep boundaries **coarseâ€‘grained**; never call `runOnJS` per frame.

---

## ğŸš¨ Pitfalls (4.x)

1. Calling **React hooks** inside worklets (donâ€™t).
2. Reading `.value` inside React render or outside a worklet.
3. Large closure captures; prefer primitives/params/shared values.
4. Perâ€‘frame `className` churn; derive styles from shared values.
5. Multiple writes to the same shared value in one frame.
6. Forgetting `cancelAnimation` on long/looping sequences.
7. Overusing `runOnJS` in `onUpdate` handlers.

---

## âš™ï¸ Expo SDKÂ 54 specifics

* ReanimatedÂ 4.x is bundled with SDKÂ 54.
* RNGH: **v2 Gesture API**.
* Babel: `react-native-reanimated/plugin` via `babel-preset-expo` â†’ no manual changes typically needed.
* Install deps with the Expoâ€‘pinned versions:
  `npx expo install react-native-reanimated react-native-gesture-handler`.

---

**Short agent take**: Tailwind for static, Reanimated for dynamic; keep `className` stable; prefer layout/shared transitions; honor Reduced Motion; use tokens; prefix `sharedTransitionTag` by feature; keep heavy logic on the UI runtime and cross to JS only for sideâ€‘effects/state.

---

## ğŸ§± Motion tokens & Reduced Motion (GrowBro)

* Centralize **durations** and **easings** so animations feel consistent and can be themed.

```ts
// src/lib/animations/motion.ts
import { Easing, ReduceMotion } from 'react-native-reanimated';
export const motion = {
  dur: { xs: 120, sm: 180, md: 260, lg: 360 },
  ease: {
    standard: Easing.bezier(0.2, 0, 0, 1),
    emphasized: Easing.bezier(0.2, 0, 0, 1),
    decel: Easing.bezier(0, 0, 0.2, 1),
  },
};
export const withRM = (anim: any) => anim.reduceMotion?.(ReduceMotion.System) ?? anim;
```

**Use**

```tsx
entering={withRM(FadeInUp.duration(motion.dur.md).easing(motion.ease.standard))}
```

* `withRM` ensures system **Reduced Motion** is always respected.

## ğŸ¤ Gesture composition (cheat)

* `Gesture.Simultaneous(pan, pinch)` â€” both can run.
* `Gesture.Exclusive(press, pan)` â€” press wins unless pan exceeds threshold.
* `Gesture.Race(longPress, tap)` â€” first to activate cancels others.

> Heavy math stays in `onUpdate` worklets; use `runOnJS` only in `onEnd`.

## ğŸ§­ Scroll recipe (programmatic)

```ts
const scrollRef = useAnimatedRef<Animated.ScrollView>();
scrollTo(scrollRef, 0, y.value, true);
```

* Prefer `scrollTo` over style/position hacks; keep `y` as a shared value.

## ğŸ·ï¸ Shared values naming (GrowBro)

* Prefix with **feature** + **unit**: `feedY`, `cardScale`, `opacityA`.
* Derived values suffix `D`: `cardScaleD` derived from `cardScale`.

## âœ… QA checklist (ultraâ€‘short)

* Reduced Motion respected everywhere?
* List insert/remove uses `layout` and looks smooth?
* Any perâ€‘frame `runOnJS` or class churn left?
* Looping animations canceled on unmount?
* Style keys stable per frame; compute once in `useDerivedValue`, reuse across styles.