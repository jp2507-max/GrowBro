---
description: Adding Animations
alwaysApply: false
---

# ðŸŽ¬ React Native Reanimated Productionâ€¯Cheatsheet (**3.17.5**, Expo SDKâ€¯53)

_Last updatedÂ AugÂ 2025 â€¢ â‰ˆ250Â lines_

---

## ðŸš€ Worklets in 3.17.5 â€” What actually runs on the UI thread

- **Autoâ€‘workletization is ON**: Callbacks passed to Reanimated APIs (e.g. `useAnimatedStyle`, `useDerivedValue`, animation finish callbacks, gesture callbacks) run on the **UI thread** without adding `'worklet'`.
- **Add `'worklet'` manually ifâ€¦**

  1. you **use imported/external functions** as worklets,
  2. the function is the **result of an expression** (e.g. conditional/ternary),
  3. you define worklet callbacks **inside custom hooks** (the plugin doesnâ€™t know your hook),
  4. you want to **workletize topâ€‘level utilities** (optionally mark the whole file at the top with `'worklet'`).

- **`runOnUI`**: Inline functions passed to `runOnUI` are workletized automatically; external references still need `'worklet'`.
- âœ” **Checklist**

  - [ ] No `.value` access in React render (derive styles/values inside worklets)
  - [ ] `cancelAnimation` on unmount for long/looping animations

```ts
// Autoâ€‘workletized (hook callback â‡’ UI thread)
const animatedStyle = useAnimatedStyle(() => ({
  transform: [{ scale: scale.value }],
}));

// Manual â€” imported function used as a worklet
export function importedWorklet() {
  'worklet';
  return { width: 100 };
}
const s = useAnimatedStyle(importedWorklet);

// Conditional/expression â€” add 'worklet' in both branches
const makeStyle = someCond
  ? () => {
      'worklet';
      return { opacity: 1 };
    }
  : () => {
      'worklet';
      return { opacity: 0.5 };
    };
const st = useAnimatedStyle(makeStyle);

// Wholeâ€‘file worklet (optional utility file)
('worklet');
export function cardShadow() {
  return { shadowOpacity: 0.15 };
}
```

---

## ðŸ“¦ Minimum Imports (3.17.5)

```ts
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnUI,
  interpolateColor as rInterpolateColor,
  cancelAnimation,
} from 'react-native-reanimated';

import { Gesture, GestureDetector } from 'react-native-gesture-handler'; // RNGH v2
```

> Use RNGHâ€™s **Gesture API** (`Gesture.*`) with **`GestureDetector`** instead of the old handler components.

---

## ðŸŽ¯ Core Patterns

### Shared Values

```ts
const width = useSharedValue(100);
width.value = withSpring(200);
```

### `useAnimatedStyle`

```ts
const st = useAnimatedStyle(() => ({
  transform: [{ translateX: offset.value }],
  opacity: isVisible.value ? 1 : 0,
}));
// Donâ€™t mutate shared values inside this callback (read/assign only).
```

### Color Interpolation

```ts
const bg = useAnimatedStyle(() => ({
  backgroundColor: rInterpolateColor(progress.value, [0, 1], ['#F00', '#0F0']),
}));
```

### NativeWind

- **Static**: `className="bg-blue-500 p-4 rounded-lg"`
- **Dynamic**: `style={animatedStyle}`

---

## ðŸ‘† Modern Gesture API (RNGH v2)

```tsx
const x = useSharedValue(0);
const y = useSharedValue(0);
const ctx = useSharedValue({ x: 0, y: 0 });

const pan = Gesture.Pan()
  .onStart(() => {
    ctx.value = { x: x.value, y: y.value };
  })
  .onUpdate((e) => {
    x.value = ctx.value.x + e.translationX;
    y.value = ctx.value.y + e.translationY;
  })
  .onEnd(() => {
    x.value = withSpring(0);
    y.value = withSpring(0);
  });

const style = useAnimatedStyle(() => ({
  transform: [{ translateX: x.value }, { translateY: y.value }],
}));

return (
  <GestureDetector gesture={pan}>
    <Animated.View style={style} />
  </GestureDetector>
);
```

### Migration Map

Replace âžœ With
â€¢ `useAnimatedGestureHandler` âžœ `Gesture.*()` (+ `GestureDetector`)
â€¢ `PanGestureHandler` âžœ `GestureDetector`
â€¢ `onActive` âžœ `onUpdate`
â€¢ `ctx` param âžœ external `useSharedValue`

> `useAnimatedGestureHandler` is **deprecated in 3.x** and slated for removal in the next major.

---

## â™»ï¸ Cleanup & Chaining

```ts
useEffect(() => () => cancelAnimation(offset), []); // cleanup on unmount
```

```ts
offset.value = withSpring(100, {}, (finished) => {
  // finish callbacks are treated as worklets in this context
  if (finished) {
    scale.value = withSpring(1.2);
  }
});
```

---

## ðŸ”§ Hooks vs. Direct Utilities

- **Direct usage** in components is smallest & fastest.
- **Custom hooks** in `@/lib/animations` are great for reuse (cards, buttons, modals), **but**: mark internal callbacks with `'worklet'` (the plugin canâ€™t autoâ€‘register your hook).
- Avoid overâ€‘abstraction for simple oneâ€‘offs.

---

## ðŸ§µ Crossing Threads

- **`runOnUI`**: start UIâ€‘thread work from JS (inline callback is autoâ€‘workletized).
- **`runOnJS`**: call JS/React state from a worklet (e.g., gesture/timing finish callbacks). Never set React state directly inside a UI worklet.

```ts
const tap = Gesture.Tap().onEnd(() => {
  runOnJS(setOpen)(true);
});
```

---

## ðŸš¨ Pitfalls (3.17.5)

1. Donâ€™t compute with `.value` during React render (derive inside worklets).
2. Donâ€™t **mutate** inside `useAnimatedStyle` (just read/assign SVs).
3. Alias `interpolateColor` to avoid naming collisions.
4. **Cancel** long/looping animations on unmount.
5. Keep NativeWind sizing units consistent.
6. For **imports/expressions/custom hooks**, add `'worklet'` explicitly.

---

## âš™ï¸ Expo SDK 53 Specifics

- **Bundled Reanimated**: `~3.17.4` (compatible with 3.17.5).
- **Babel**: `react-native-reanimated/plugin` is autoâ€‘configured via `babel-preset-expo` â€” no manual setup in most Expo apps.

> Install with `npx expo install react-native-reanimated` to match the SDK.

---

## ðŸ”„ If you ever target < 3.x

Older versions often required explicit `'worklet'` in hook callbacks:

```ts
const oldStyle = useAnimatedStyle(() => {
  'worklet';
  return { scale: sv.value };
});
```

---

**Status:** ReanimatedÂ 3.17.5 is productionâ€‘ready in ExpoÂ SDKâ€¯53 â€” autoâ€‘workletization, modern Gesture API, and clear migration paths.
